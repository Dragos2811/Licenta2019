'''
Created on Jun 4, 2019

@author: Dragos
'''
from music21 import converter,instrument, note, stream, chord
def numNote(pattern):
    i = 0
    while sum(pattern[i]) != 0:
        i += 1
    return i
def create_midi(prediction_output):
    """ convert the output from the prediction to notes and create a midi file
        from the notes """
    offset = 0
    output_notes = []
    n = ["C","C#","D","E-","E","F","F#","G","G#","A","B-","B"]
    pitchnames = [note.Note(no + str(octave)).nameWithOctave for octave in range(8) for no in n ]
    pitchnames.append("C8")
    # create note and chord objects based on the values generated by the model
    for pattern in prediction_output:
        # pattern is a chord
        if numNote(pattern) > 1:
            notes = []
            for pp in pattern:
                d = max(pp)
                if d == 0:
                    break
                new_note = note.Note(pitchnames[pp.index(d)])
                new_note.storedInstrument = instrument.Piano()
                #new_note.duration.quarterLength = d
                notes.append(new_note)
            new_chord = chord.Chord(notes)
            new_chord.offset = offset
            output_notes.append(new_chord)
            #offset += d
        else:
            d = max(pattern[0])
            new_note = note.Note(pitchnames[pattern[0].index(d)])
            new_note.offset = offset
            new_note.duration.quarterLength = d
            new_note.storedInstrument = instrument.Piano()
            output_notes.append(new_note)

            #offset += d
        offset += 0.5
    midi_stream = stream.Stream(output_notes)

    midi_stream.write('midi', fp='test_output.mp3')
def one_hot_encoded(n,n_vocab,d):
    a = [0 for _ in range(n_vocab)]
    a[n] = d
    return a
def get_notes():
    """ Get all the notes and chords from the midi files in the ./midi_songs directory """
    notes = []
    n = ["C","C#","D","E-","E","F","F#","G","G#","A","B-","B"]
    pitchnames = [note.Note(no + str(octave)).nameWithOctave for octave in range(8) for no in n ]
    pitchnames.append("C8")
    n_vocab = len(pitchnames)
    file = "midi_songs/Cids.mid"

    midi = converter.parse(file)

    print("Parsing %s" % file)

    notes_to_parse = None

    try: # file has instrument parts
        s2 = instrument.partitionByInstrument(midi)
        notes_to_parse = s2.parts[0].recurse() 
    except: # file has notes in a flat structure
        notes_to_parse = midi.flat.notes

    for element in notes_to_parse:
        if isinstance(element, note.Note):
            d = element.duration.quarterLength
            c = [one_hot_encoded(pitchnames.index(element.nameWithOctave), n_vocab,d)]
            for i in range(1,5):
                c.append([0 for _ in range(n_vocab)])
            notes.append(c)
        #elif isinstance(element,  note.Rest):
           #notes.append(one_hot_encoded([], n_vocab))
        elif isinstance(element, chord.Chord):
            d = element.duration.quarterLength
            c = []
            for i,nota in enumerate(element._notes):
                if i < 5:
                    c.append(one_hot_encoded(pitchnames.index(nota.nameWithOctave), n_vocab,d))
            while i < 5:
                c.append([0 for _ in range(n_vocab)])
                i += 1
            notes.append(c)
                
    
    return notes

